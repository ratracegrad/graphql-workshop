(window.webpackJsonp=window.webpackJsonp||[]).push([[315],{481:function(a,n,c){"use strict";c.r(n);var e=c(0),t=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,n=a.$createElement,c=a._self._c||n;return c("div",{staticClass:"content"},[c("h2",{attrs:{id:"nan-callback"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#nan-callback","aria-hidden":"true"}},[a._v("#")]),a._v(" Nan::Callback")]),a._v(" "),c("p",[c("code",[a._v("Nan::Callback")]),a._v(" makes it easier to use "),c("code",[a._v("v8::Function")]),a._v(" handles as callbacks. A class that wraps a "),c("code",[a._v("v8::Function")]),a._v(" handle, protecting it from garbage collection and making it particularly useful for storage and use across asynchronous execution.")]),a._v(" "),c("ul",[c("li",[c("a",{attrs:{href:"#api_nan_callback"}},[c("b",[c("code",[a._v("Nan::Callback")])])])])]),a._v(" "),c("p",[c("a",{attrs:{name:"api_nan_callback"}})]),a._v(" "),c("h3",{attrs:{id:"nan-callback-2"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#nan-callback-2","aria-hidden":"true"}},[a._v("#")]),a._v(" Nan::Callback")]),a._v(" "),c("div",{staticClass:"language-c++ extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[a._v("class Callback {\n public:\n  Callback();\n\n  explicit Callback(const v8::Local<v8::Function> &fn);\n\n  ~Callback();\n\n  bool operator==(const Callback &other) const;\n\n  bool operator!=(const Callback &other) const;\n\n  v8::Local<v8::Function> operator*() const;\n\n  MaybeLocal<v8::Value> operator()(AsyncResource* async_resource,\n                                   v8::Local<v8::Object> target,\n                                   int argc = 0,\n                                   v8::Local<v8::Value> argv[] = 0) const;\n\n  MaybeLocal<v8::Value> operator()(AsyncResource* async_resource,\n                                   int argc = 0,\n                                   v8::Local<v8::Value> argv[] = 0) const;\n\n  void SetFunction(const v8::Local<v8::Function> &fn);\n\n  v8::Local<v8::Function> GetFunction() const;\n\n  bool IsEmpty() const;\n\n  void Reset(const v8::Local<v8::Function> &fn);\n\n  void Reset();\n\n  MaybeLocal<v8::Value> Call(v8::Local<v8::Object> target,\n                            int argc,\n                            v8::Local<v8::Value> argv[],\n                            AsyncResource* async_resource) const;\n  MaybeLocal<v8::Value> Call(int argc,\n                             v8::Local<v8::Value> argv[],\n                             AsyncResource* async_resource) const;\n\n  // Deprecated versions. Use the versions that accept an async_resource instead\n  // as they run the callback in the correct async context as specified by the\n  // resource. If you want to call a synchronous JS function (i.e. on a\n  // non-empty JS stack), you can use Nan::Call instead.\n  v8::Local<v8::Value> operator()(v8::Local<v8::Object> target,\n                                  int argc = 0,\n                                  v8::Local<v8::Value> argv[] = 0) const;\n\n  v8::Local<v8::Value> operator()(int argc = 0,\n                                  v8::Local<v8::Value> argv[] = 0) const;\n  v8::Local<v8::Value> Call(v8::Local<v8::Object> target,\n                            int argc,\n                            v8::Local<v8::Value> argv[]) const;\n\n  v8::Local<v8::Value> Call(int argc, v8::Local<v8::Value> argv[]) const;\n};\n")])])]),c("p",[a._v("Example usage:")]),a._v(" "),c("div",{staticClass:"language-c++ extra-class"},[c("pre",{pre:!0,attrs:{class:"language-text"}},[c("code",[a._v("v8::Local<v8::Function> function;\nNan::Callback callback(function);\ncallback.Call(0, 0);\n")])])])])}],!1,null,null,null);n.default=t.exports}}]);
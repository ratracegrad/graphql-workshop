(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{334:function(e,t,i){"use strict";i.r(t);var s=i(0),n=Object(s.a)({},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),i("p",[e._v("A tiny fast zlib stream built on "),i("a",{attrs:{href:"http://npm.im/minipass",target:"_blank",rel:"noopener noreferrer"}},[e._v("minipass"),i("OutboundLink")],1),e._v("\nand Node.js's zlib binding.")]),e._v(" "),i("p",[e._v("This module was created to serve the needs of\n"),i("a",{attrs:{href:"http://npm.im/tar",target:"_blank",rel:"noopener noreferrer"}},[e._v("node-tar"),i("OutboundLink")],1),e._v(" v2.  If your needs are different, then\nit may not be for you.")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),i("p",[e._v("This module compresses and decompresses the data as fast as you feed\nit in.  It is synchronous, and runs on the main process thread.  Zlib\noperations can be high CPU, but they're very fast, and doing it this\nway means much less bookkeeping and artificial deferral.")]),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),i("p",[e._v("It is thus the responsibility of the reader and writer to manage their\nown consumption and process execution flow.")]),e._v(" "),i("p",[e._v("The goal is to compress and decompress as fast as possible, even for\nfiles that are too large to store all in one buffer.")]),e._v(" "),e._m(6)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"minizlib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#minizlib","aria-hidden":"true"}},[this._v("#")]),this._v(" minizlib")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"how-does-this-differ-from-the-streams-in-require-zlib"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#how-does-this-differ-from-the-streams-in-require-zlib","aria-hidden":"true"}},[this._v("#")]),this._v(" How does this differ from the streams in "),t("code",[this._v("require('zlib')")]),this._v("?")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("First, there are no convenience methods to compress or decompress a\nbuffer.  If you want those, use the built-in "),t("code",[this._v("zlib")]),this._v(" module.  This is\nonly streams.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Node's built in zlib streams are built on top of "),t("code",[this._v("stream.Transform")]),this._v(".\nThey do the maximally safe thing with respect to consistent\nasynchrony, buffering, and backpressure.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("This module "),t("em",[this._v("does")]),this._v(" support backpressure, and will buffer output chunks\nthat are not consumed, but is less of a mediator between the input and\noutput.  There is no high or low watermarks, no state objects, and so\nartificial async deferrals.  It will not protect you from Zalgo.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("If you write, data will be emitted right away.  If you write\neverything synchronously in one tick, and you are listening to the\n"),t("code",[this._v("data")]),this._v(" event to consume it, then it'll all be emitted right away in\nthat same tick.  If you want data to be emitted in the next tick, then\nwrite it in the next tick.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("The API is very similar to the built-in zlib module.  There are\nclasses that you instantiate with "),t("code",[this._v("new")]),this._v(" and they are streams that can\nbe piped together.")])}],!1,null,null,null);t.default=n.exports}}]);
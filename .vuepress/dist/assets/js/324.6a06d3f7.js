(window.webpackJsonp=window.webpackJsonp||[]).push([[324],{490:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),n("p",[e._v("Also see the V8 Embedders Guide section on "),n("a",{attrs:{href:"https://developers.google.com/v8/embed#handles",target:"_blank",rel:"noopener noreferrer"}},[e._v("Handles and Garbage Collection"),n("OutboundLink")],1),e._v(".")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(7),e._v(" "),e._m(8),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/d4/dca/classv8_1_1_persistent_base.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("PersistentBase")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(9),e._v(" "),e._m(10),e._m(11),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(14),e._v(" "),e._m(15),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/de/d73/classv8_1_1_non_copyable_persistent_traits.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("NonCopyablePersistentTraits")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(19),e._v(" "),e._m(20),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/da/d5c/structv8_1_1_copyable_persistent_traits.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("CopyablePersistentTraits")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(24),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/d2/d78/classv8_1_1_persistent.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("Persistent")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/d5/d40/classv8_1_1_global.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("Global")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(32),n("p",[e._v("Example usage:")]),e._v(" "),e._m(33),n("p",[e._v("See the V8 documentation for "),n("a",{attrs:{href:"https://v8docs.nodesource.com/node-8.11/d8/d06/classv8_1_1_weak_callback_info.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("WeakCallbackInfo")]),n("OutboundLink")],1),e._v(" for further information.")]),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),e._m(36),e._v(" "),n("p",[e._v("Definition:")]),e._v(" "),e._m(37)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"persistent-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#persistent-references","aria-hidden":"true"}},[this._v("#")]),this._v(" Persistent references")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("An object reference that is independent of any "),n("code",[e._v("HandleScope")]),e._v(" is a "),n("em",[e._v("persistent")]),e._v(" reference. Where a "),n("code",[e._v("Local")]),e._v(" handle only lives as long as the "),n("code",[e._v("HandleScope")]),e._v(" in which it was allocated, a "),n("code",[e._v("Persistent")]),e._v(" handle remains valid until it is explicitly disposed.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Due to the evolution of the V8 API, it is necessary for NAN to provide a wrapper implementation of the "),t("code",[this._v("Persistent")]),this._v(" classes to supply compatibility across the V8 versions supported.")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[n("a",{attrs:{href:"#api_nan_persistent_base"}},[n("b",[n("code",[e._v("Nan::PersistentBase & v8::PersistentBase")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_non_copyable_persistent_traits"}},[n("b",[n("code",[e._v("Nan::NonCopyablePersistentTraits & v8::NonCopyablePersistentTraits")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_copyable_persistent_traits"}},[n("b",[n("code",[e._v("Nan::CopyablePersistentTraits & v8::CopyablePersistentTraits")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_persistent"}},[n("b",[n("code",[e._v("Nan::Persistent")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_global"}},[n("b",[n("code",[e._v("Nan::Global")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_weak_callback_info"}},[n("b",[n("code",[e._v("Nan::WeakCallbackInfo")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#api_nan_weak_callback_type"}},[n("b",[n("code",[e._v("Nan::WeakCallbackType")])])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_persistent_base"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-persistentbase-v8-persistentbase"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-persistentbase-v8-persistentbase","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::PersistentBase & v8::PersistentBase")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A persistent handle contains a reference to a storage cell in V8 which holds an object value and which is updated by the garbage collector whenever the object is moved. A new storage cell can be created using the constructor or "),t("code",[this._v("Nan::PersistentBase::Reset()")]),this._v(". Existing handles can be disposed using an argument-less "),t("code",[this._v("Nan::PersistentBase::Reset()")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("(note: this is implemented as "),t("code",[this._v("Nan::PersistentBase")]),this._v(" for older versions of V8 and the native "),t("code",[this._v("v8::PersistentBase")]),this._v(" is used for newer versions of V8)")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T> class PersistentBase {\n public:\n  /**\n   * If non-empty, destroy the underlying storage cell\n   */\n  void Reset();\n\n  /**\n   * If non-empty, destroy the underlying storage cell and create a new one with\n   * the contents of another if it is also non-empty\n   */\n  template<typename S> void Reset(const v8::Local<S> &other);\n\n  /**\n   * If non-empty, destroy the underlying storage cell and create a new one with\n   * the contents of another if it is also non-empty\n   */\n  template<typename S> void Reset(const PersistentBase<S> &other);\n\n  /** Returns true if the handle is empty. */\n  bool IsEmpty() const;\n\n  /**\n   * If non-empty, destroy the underlying storage cell\n   * IsEmpty() will return true after this call.\n   */\n  void Empty();\n\n  template<typename S> bool operator==(const PersistentBase<S> &that);\n\n  template<typename S> bool operator==(const v8::Local<S> &that);\n\n  template<typename S> bool operator!=(const PersistentBase<S> &that);\n\n  template<typename S> bool operator!=(const v8::Local<S> &that);\n\n   /**\n   *  Install a finalization callback on this object.\n   *  NOTE: There is no guarantee as to *when* or even *if* the callback is\n   *  invoked. The invocation is performed solely on a best effort basis.\n   *  As always, GC-based finalization should *not* be relied upon for any\n   *  critical form of resource management! At the moment you can either\n   *  specify a parameter for the callback or the location of two internal\n   *  fields in the dying object.\n   */\n  template<typename P>\n  void SetWeak(P *parameter,\n               typename WeakCallbackInfo<P>::Callback callback,\n               WeakCallbackType type);\n\n  void ClearWeak();\n\n  /**\n   * Marks the reference to this object independent. Garbage collector is free\n   * to ignore any object groups containing this object. Weak callback for an\n   * independent handle should not assume that it will be preceded by a global\n   * GC prologue callback or followed by a global GC epilogue callback.\n   */\n  void MarkIndependent() const;\n\n  bool IsIndependent() const;\n\n  /** Checks if the handle holds the only reference to an object. */\n  bool IsNearDeath() const;\n\n  /** Returns true if the handle's reference is weak.  */\n  bool IsWeak() const\n};\n")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("strong",[e._v("Tip:")]),e._v(" To get a "),n("code",[e._v("v8::Local")]),e._v(" reference to the original object back from a "),n("code",[e._v("PersistentBase")]),e._v(" or "),n("code",[e._v("Persistent")]),e._v(" object:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("v8::Local<v8::Object> object = Nan::New(persistent);\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_non_copyable_persistent_traits"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-noncopyablepersistenttraits-v8-noncopyablepersistenttraits"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-noncopyablepersistenttraits-v8-noncopyablepersistenttraits","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::NonCopyablePersistentTraits & v8::NonCopyablePersistentTraits")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Default traits for "),t("code",[this._v("Nan::Persistent")]),this._v(". This class does not allow use of the a copy constructor or assignment operator. At present "),t("code",[this._v("kResetInDestructor")]),this._v(" is not set, but that will change in a future version.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("(note: this is implemented as "),t("code",[this._v("Nan::NonCopyablePersistentTraits")]),this._v(" for older versions of V8 and the native "),t("code",[this._v("v8::NonCopyablePersistentTraits")]),this._v(" is used for newer versions of V8)")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T> class NonCopyablePersistentTraits {\n public:\n  typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;\n\n  static const bool kResetInDestructor = false;\n\n  template<typename S, typename M>\n  static void Copy(const Persistent<S, M> &source,\n                   NonCopyablePersistent *dest);\n\n  template<typename O> static void Uncompilable();\n};\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_copyable_persistent_traits"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-copyablepersistenttraits-v8-copyablepersistenttraits"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-copyablepersistenttraits-v8-copyablepersistenttraits","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::CopyablePersistentTraits & v8::CopyablePersistentTraits")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A helper class of traits to allow copying and assignment of "),t("code",[this._v("Persistent")]),this._v(". This will clone the contents of storage cell, but not any of the flags, etc..")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("(note: this is implemented as "),t("code",[this._v("Nan::CopyablePersistentTraits")]),this._v(" for older versions of V8 and the native "),t("code",[this._v("v8::NonCopyablePersistentTraits")]),this._v(" is used for newer versions of V8)")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T>\nclass CopyablePersistentTraits {\n public:\n  typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;\n\n  static const bool kResetInDestructor = true;\n\n  template<typename S, typename M>\n  static void Copy(const Persistent<S, M> &source,\n                   CopyablePersistent *dest);\n};\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_persistent"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-persistent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-persistent","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::Persistent")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A type of "),t("code",[this._v("PersistentBase")]),this._v(" which allows copy and assignment. Copy, assignment and destructor behavior is controlled by the traits class "),t("code",[this._v("M")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T, typename M = NonCopyablePersistentTraits<T> >\nclass Persistent;\n\ntemplate<typename T, typename M> class Persistent : public PersistentBase<T> {\n public:\n /**\n  * A Persistent with no storage cell.\n  */\n  Persistent();\n\n  /**\n   * Construct a Persistent from a v8::Local. When the v8::Local is non-empty, a\n   * new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  template<typename S> Persistent(v8::Local<S> that);\n\n  /**\n   * Construct a Persistent from a Persistent. When the Persistent is non-empty,\n   * a new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  Persistent(const Persistent &that);\n\n  /**\n   * The copy constructors and assignment operator create a Persistent exactly\n   * as the Persistent constructor, but the Copy function from the traits class\n   * is called, allowing the setting of flags based on the copied Persistent.\n   */\n  Persistent &operator=(const Persistent &that);\n\n  template <typename S, typename M2>\n  Persistent &operator=(const Persistent<S, M2> &that);\n\n  /**\n   * The destructor will dispose the Persistent based on the kResetInDestructor\n   * flags in the traits class.  Since not calling dispose can result in a\n   * memory leak, it is recommended to always set this flag.\n   */\n  ~Persistent();\n};\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_global"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-global"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-global","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::Global")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("A type of "),t("code",[this._v("PersistentBase")]),this._v(" which has move semantics.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T> class Global : public PersistentBase<T> {\n public:\n  /**\n   * A Global with no storage cell.\n   */\n  Global();\n\n  /**\n   * Construct a Global from a v8::Local. When the v8::Local is non-empty, a new\n   * storage cell is created pointing to the same object, and no flags are set.\n   */\n  template<typename S> Global(v8::Local<S> that);\n  /**\n   * Construct a Global from a PersistentBase. When the Persistent is non-empty,\n   * a new storage cell is created pointing to the same object, and no flags are\n   * set.\n   */\n  template<typename S> Global(const PersistentBase<S> &that);\n\n  /**\n   * Pass allows returning globals from functions, etc.\n   */\n  Global Pass();\n};\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_weak_callback_info"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-weakcallbackinfo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-weakcallbackinfo","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::WeakCallbackInfo")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("code",[this._v("Nan::WeakCallbackInfo")]),this._v(" is used as an argument when setting a persistent reference as weak. You may need to free any external resources attached to the object. It is a mirror of "),t("code",[this._v("v8:WeakCallbackInfo")]),this._v(" as found in newer versions of V8.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("template<typename T> class WeakCallbackInfo {\n public:\n  typedef void (*Callback)(const WeakCallbackInfo<T>& data);\n\n  v8::Isolate *GetIsolate() const;\n\n  /**\n   * Get the parameter that was associated with the weak handle.\n   */\n  T *GetParameter() const;\n\n  /**\n   * Get pointer from internal field, index can be 0 or 1.\n   */\n  void *GetInternalField(int index) const;\n};\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("void weakCallback(const WeakCallbackInfo<int> &data) {\n  int *parameter = data.GetParameter();\n  delete parameter;\n}\n\nPersistent<v8::Object> obj;\nint *data = new int(0);\nobj.SetWeak(data, callback, WeakCallbackType::kParameter);\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{name:"api_nan_weak_callback_type"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"nan-weakcallbacktype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nan-weakcallbacktype","aria-hidden":"true"}},[this._v("#")]),this._v(" Nan::WeakCallbackType")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("Represents the type of a weak callback.\nA weak callback of type "),n("code",[e._v("kParameter")]),e._v(" makes the supplied parameter to "),n("code",[e._v("Nan::PersistentBase::SetWeak")]),e._v(" available through "),n("code",[e._v("WeakCallbackInfo::GetParameter")]),e._v(".\nA weak callback of type "),n("code",[e._v("kInternalFields")]),e._v(" uses up to two internal fields at indices 0 and 1 on the "),n("code",[e._v("Nan::PersistentBase<v8::Object>")]),e._v(" being made weak.\nNote that only "),n("code",[e._v("v8::Object")]),e._v("s and derivatives can have internal fields.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("enum class WeakCallbackType { kParameter, kInternalFields };\n")])])])}],!1,null,null,null);t.default=s.exports}}]);